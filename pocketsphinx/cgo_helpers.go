// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Wed, 17 May 2017 17:04:46 MSK.
// By https://git.io/c-for-go. DO NOT EDIT.

package pocketsphinx

/*
#cgo pkg-config: pocketsphinx
#include "pocketsphinx.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// Ref returns a reference to C object as it is.
func (x *Decoder) Ref() *C.ps_decoder_t {
	if x == nil {
		return nil
	}
	return (*C.ps_decoder_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Decoder) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDecoderRef converts the C object reference into a raw struct reference without wrapping.
func NewDecoderRef(ref unsafe.Pointer) *Decoder {
	return (*Decoder)(ref)
}

// NewDecoder allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDecoder() *Decoder {
	return (*Decoder)(allocDecoderMemory(1))
}

// allocDecoderMemory allocates memory for type C.ps_decoder_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDecoderMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDecoderValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDecoderValue = unsafe.Sizeof([1]C.ps_decoder_t{})

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Decoder) PassRef() *C.ps_decoder_t {
	if x == nil {
		x = (*Decoder)(allocDecoderMemory(1))
	}
	return (*C.ps_decoder_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Nbest) Ref() *C.ps_nbest_t {
	if x == nil {
		return nil
	}
	return (*C.ps_nbest_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Nbest) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewNbestRef converts the C object reference into a raw struct reference without wrapping.
func NewNbestRef(ref unsafe.Pointer) *Nbest {
	return (*Nbest)(ref)
}

// NewNbest allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewNbest() *Nbest {
	return (*Nbest)(allocNbestMemory(1))
}

// allocNbestMemory allocates memory for type C.ps_nbest_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocNbestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfNbestValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfNbestValue = unsafe.Sizeof([1]C.ps_nbest_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Nbest) PassRef() *C.ps_nbest_t {
	if x == nil {
		x = (*Nbest)(allocNbestMemory(1))
	}
	return (*C.ps_nbest_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Seg) Ref() *C.ps_seg_t {
	if x == nil {
		return nil
	}
	return (*C.ps_seg_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Seg) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewSegRef converts the C object reference into a raw struct reference without wrapping.
func NewSegRef(ref unsafe.Pointer) *Seg {
	return (*Seg)(ref)
}

// NewSeg allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewSeg() *Seg {
	return (*Seg)(allocSegMemory(1))
}

// allocSegMemory allocates memory for type C.ps_seg_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSegMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSegValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSegValue = unsafe.Sizeof([1]C.ps_seg_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Seg) PassRef() *C.ps_seg_t {
	if x == nil {
		x = (*Seg)(allocSegMemory(1))
	}
	return (*C.ps_seg_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *File) Ref() *C.FILE {
	if x == nil {
		return nil
	}
	return (*C.FILE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *File) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFileRef converts the C object reference into a raw struct reference without wrapping.
func NewFileRef(ref unsafe.Pointer) *File {
	return (*File)(ref)
}

// NewFile allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFile() *File {
	return (*File)(allocFileMemory(1))
}

// allocFileMemory allocates memory for type C.FILE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFileMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFileValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFileValue = unsafe.Sizeof([1]C.FILE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *File) PassRef() *C.FILE {
	if x == nil {
		x = (*File)(allocFileMemory(1))
	}
	return (*C.FILE)(unsafe.Pointer(x))
}

// allocArgMemory allocates memory for type C.arg_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocArgMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfArgValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfArgValue = unsafe.Sizeof([1]C.arg_t{})

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}

type stringHeader struct {
	Data uintptr
	Len  int
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(unsafe.Pointer(h.Data)), C.int(h.Len))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Arg) Ref() *C.arg_t {
	if x == nil {
		return nil
	}
	return x.ref8495e8ec
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Arg) Free() {
	if x != nil && x.allocs8495e8ec != nil {
		x.allocs8495e8ec.(*cgoAllocMap).Free()
		x.ref8495e8ec = nil
	}
}

// NewArgRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewArgRef(ref unsafe.Pointer) *Arg {
	if ref == nil {
		return nil
	}
	obj := new(Arg)
	obj.ref8495e8ec = (*C.arg_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Arg) PassRef() (*C.arg_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8495e8ec != nil {
		return x.ref8495e8ec, nil
	}
	mem8495e8ec := allocArgMemory(1)
	ref8495e8ec := (*C.arg_t)(mem8495e8ec)
	allocs8495e8ec := new(cgoAllocMap)
	var cname_allocs *cgoAllocMap
	ref8495e8ec.name, cname_allocs = unpackPCharString(x.Name)
	allocs8495e8ec.Borrow(cname_allocs)

	var c_type_allocs *cgoAllocMap
	ref8495e8ec._type, c_type_allocs = (C.int)(x.Type), cgoAllocsUnknown
	allocs8495e8ec.Borrow(c_type_allocs)

	var cdeflt_allocs *cgoAllocMap
	ref8495e8ec.deflt, cdeflt_allocs = unpackPCharString(x.Deflt)
	allocs8495e8ec.Borrow(cdeflt_allocs)

	var cdoc_allocs *cgoAllocMap
	ref8495e8ec.doc, cdoc_allocs = unpackPCharString(x.Doc)
	allocs8495e8ec.Borrow(cdoc_allocs)

	x.ref8495e8ec = ref8495e8ec
	x.allocs8495e8ec = allocs8495e8ec
	return ref8495e8ec, allocs8495e8ec

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Arg) PassValue() (C.arg_t, *cgoAllocMap) {
	if x.ref8495e8ec != nil {
		return *x.ref8495e8ec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Arg) Deref() {
	if x.ref8495e8ec == nil {
		return
	}
	x.Name = packPCharString(x.ref8495e8ec.name)
	x.Type = (int32)(x.ref8495e8ec._type)
	x.Deflt = packPCharString(x.ref8495e8ec.deflt)
	x.Doc = packPCharString(x.ref8495e8ec.doc)
}

// Ref returns a reference to C object as it is.
func (x *CommandLn) Ref() *C.cmd_ln_t {
	if x == nil {
		return nil
	}
	return (*C.cmd_ln_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CommandLn) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCommandLnRef converts the C object reference into a raw struct reference without wrapping.
func NewCommandLnRef(ref unsafe.Pointer) *CommandLn {
	return (*CommandLn)(ref)
}

// NewCommandLn allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCommandLn() *CommandLn {
	return (*CommandLn)(allocCommandLnMemory(1))
}

// allocCommandLnMemory allocates memory for type C.cmd_ln_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandLnMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandLnValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCommandLnValue = unsafe.Sizeof([1]C.cmd_ln_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CommandLn) PassRef() *C.cmd_ln_t {
	if x == nil {
		x = (*CommandLn)(allocCommandLnMemory(1))
	}
	return (*C.cmd_ln_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Logmath) Ref() *C.logmath_t {
	if x == nil {
		return nil
	}
	return (*C.logmath_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Logmath) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewLogmathRef converts the C object reference into a raw struct reference without wrapping.
func NewLogmathRef(ref unsafe.Pointer) *Logmath {
	return (*Logmath)(ref)
}

// NewLogmath allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewLogmath() *Logmath {
	return (*Logmath)(allocLogmathMemory(1))
}

// allocLogmathMemory allocates memory for type C.logmath_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLogmathMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLogmathValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfLogmathValue = unsafe.Sizeof([1]C.logmath_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Logmath) PassRef() *C.logmath_t {
	if x == nil {
		x = (*Logmath)(allocLogmathMemory(1))
	}
	return (*C.logmath_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Fe) Ref() *C.fe_t {
	if x == nil {
		return nil
	}
	return (*C.fe_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Fe) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFeRef converts the C object reference into a raw struct reference without wrapping.
func NewFeRef(ref unsafe.Pointer) *Fe {
	return (*Fe)(ref)
}

// NewFe allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFe() *Fe {
	return (*Fe)(allocFeMemory(1))
}

// allocFeMemory allocates memory for type C.fe_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFeValue = unsafe.Sizeof([1]C.fe_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Fe) PassRef() *C.fe_t {
	if x == nil {
		x = (*Fe)(allocFeMemory(1))
	}
	return (*C.fe_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Feat) Ref() *C.feat_t {
	if x == nil {
		return nil
	}
	return (*C.feat_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Feat) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFeatRef converts the C object reference into a raw struct reference without wrapping.
func NewFeatRef(ref unsafe.Pointer) *Feat {
	return (*Feat)(ref)
}

// NewFeat allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFeat() *Feat {
	return (*Feat)(allocFeatMemory(1))
}

// allocFeatMemory allocates memory for type C.feat_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFeatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFeatValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFeatValue = unsafe.Sizeof([1]C.feat_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Feat) PassRef() *C.feat_t {
	if x == nil {
		x = (*Feat)(allocFeatMemory(1))
	}
	return (*C.feat_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Lattice) Ref() *C.ps_lattice_t {
	if x == nil {
		return nil
	}
	return (*C.ps_lattice_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Lattice) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewLatticeRef converts the C object reference into a raw struct reference without wrapping.
func NewLatticeRef(ref unsafe.Pointer) *Lattice {
	return (*Lattice)(ref)
}

// NewLattice allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewLattice() *Lattice {
	return (*Lattice)(allocLatticeMemory(1))
}

// allocLatticeMemory allocates memory for type C.ps_lattice_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLatticeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLatticeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfLatticeValue = unsafe.Sizeof([1]C.ps_lattice_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Lattice) PassRef() *C.ps_lattice_t {
	if x == nil {
		x = (*Lattice)(allocLatticeMemory(1))
	}
	return (*C.ps_lattice_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Latnode) Ref() *C.ps_latnode_t {
	if x == nil {
		return nil
	}
	return (*C.ps_latnode_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Latnode) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewLatnodeRef converts the C object reference into a raw struct reference without wrapping.
func NewLatnodeRef(ref unsafe.Pointer) *Latnode {
	return (*Latnode)(ref)
}

// NewLatnode allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewLatnode() *Latnode {
	return (*Latnode)(allocLatnodeMemory(1))
}

// allocLatnodeMemory allocates memory for type C.ps_latnode_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLatnodeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLatnodeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfLatnodeValue = unsafe.Sizeof([1]C.ps_latnode_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Latnode) PassRef() *C.ps_latnode_t {
	if x == nil {
		x = (*Latnode)(allocLatnodeMemory(1))
	}
	return (*C.ps_latnode_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *LatnodeIter) Ref() *C.ps_latnode_iter_t {
	if x == nil {
		return nil
	}
	return (*C.ps_latnode_iter_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *LatnodeIter) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewLatnodeIterRef converts the C object reference into a raw struct reference without wrapping.
func NewLatnodeIterRef(ref unsafe.Pointer) *LatnodeIter {
	return (*LatnodeIter)(ref)
}

// NewLatnodeIter allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewLatnodeIter() *LatnodeIter {
	return (*LatnodeIter)(allocLatnodeIterMemory(1))
}

// allocLatnodeIterMemory allocates memory for type C.ps_latnode_iter_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLatnodeIterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLatnodeIterValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfLatnodeIterValue = unsafe.Sizeof([1]C.ps_latnode_iter_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *LatnodeIter) PassRef() *C.ps_latnode_iter_t {
	if x == nil {
		x = (*LatnodeIter)(allocLatnodeIterMemory(1))
	}
	return (*C.ps_latnode_iter_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Latlink) Ref() *C.ps_latlink_t {
	if x == nil {
		return nil
	}
	return (*C.ps_latlink_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Latlink) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewLatlinkRef converts the C object reference into a raw struct reference without wrapping.
func NewLatlinkRef(ref unsafe.Pointer) *Latlink {
	return (*Latlink)(ref)
}

// NewLatlink allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewLatlink() *Latlink {
	return (*Latlink)(allocLatlinkMemory(1))
}

// allocLatlinkMemory allocates memory for type C.ps_latlink_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLatlinkMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLatlinkValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfLatlinkValue = unsafe.Sizeof([1]C.ps_latlink_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Latlink) PassRef() *C.ps_latlink_t {
	if x == nil {
		x = (*Latlink)(allocLatlinkMemory(1))
	}
	return (*C.ps_latlink_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *LatlinkIter) Ref() *C.ps_latlink_iter_t {
	if x == nil {
		return nil
	}
	return (*C.ps_latlink_iter_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *LatlinkIter) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewLatlinkIterRef converts the C object reference into a raw struct reference without wrapping.
func NewLatlinkIterRef(ref unsafe.Pointer) *LatlinkIter {
	return (*LatlinkIter)(ref)
}

// NewLatlinkIter allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewLatlinkIter() *LatlinkIter {
	return (*LatlinkIter)(allocLatlinkIterMemory(1))
}

// allocLatlinkIterMemory allocates memory for type C.ps_latlink_iter_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLatlinkIterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLatlinkIterValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfLatlinkIterValue = unsafe.Sizeof([1]C.ps_latlink_iter_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *LatlinkIter) PassRef() *C.ps_latlink_iter_t {
	if x == nil {
		x = (*LatlinkIter)(allocLatlinkIterMemory(1))
	}
	return (*C.ps_latlink_iter_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *NgramModel) Ref() *C.ngram_model_t {
	if x == nil {
		return nil
	}
	return (*C.ngram_model_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *NgramModel) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewNgramModelRef converts the C object reference into a raw struct reference without wrapping.
func NewNgramModelRef(ref unsafe.Pointer) *NgramModel {
	return (*NgramModel)(ref)
}

// NewNgramModel allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewNgramModel() *NgramModel {
	return (*NgramModel)(allocNgramModelMemory(1))
}

// allocNgramModelMemory allocates memory for type C.ngram_model_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocNgramModelMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfNgramModelValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfNgramModelValue = unsafe.Sizeof([1]C.ngram_model_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *NgramModel) PassRef() *C.ngram_model_t {
	if x == nil {
		x = (*NgramModel)(allocNgramModelMemory(1))
	}
	return (*C.ngram_model_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *NgramClass) Ref() *C.ngram_class_t {
	if x == nil {
		return nil
	}
	return (*C.ngram_class_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *NgramClass) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewNgramClassRef converts the C object reference into a raw struct reference without wrapping.
func NewNgramClassRef(ref unsafe.Pointer) *NgramClass {
	return (*NgramClass)(ref)
}

// NewNgramClass allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewNgramClass() *NgramClass {
	return (*NgramClass)(allocNgramClassMemory(1))
}

// allocNgramClassMemory allocates memory for type C.ngram_class_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocNgramClassMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfNgramClassValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfNgramClassValue = unsafe.Sizeof([1]C.ngram_class_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *NgramClass) PassRef() *C.ngram_class_t {
	if x == nil {
		x = (*NgramClass)(allocNgramClassMemory(1))
	}
	return (*C.ngram_class_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *NgramIter) Ref() *C.ngram_iter_t {
	if x == nil {
		return nil
	}
	return (*C.ngram_iter_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *NgramIter) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewNgramIterRef converts the C object reference into a raw struct reference without wrapping.
func NewNgramIterRef(ref unsafe.Pointer) *NgramIter {
	return (*NgramIter)(ref)
}

// NewNgramIter allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewNgramIter() *NgramIter {
	return (*NgramIter)(allocNgramIterMemory(1))
}

// allocNgramIterMemory allocates memory for type C.ngram_iter_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocNgramIterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfNgramIterValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfNgramIterValue = unsafe.Sizeof([1]C.ngram_iter_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *NgramIter) PassRef() *C.ngram_iter_t {
	if x == nil {
		x = (*NgramIter)(allocNgramIterMemory(1))
	}
	return (*C.ngram_iter_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *NgramModelSetIter) Ref() *C.ngram_model_set_iter_t {
	if x == nil {
		return nil
	}
	return (*C.ngram_model_set_iter_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *NgramModelSetIter) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewNgramModelSetIterRef converts the C object reference into a raw struct reference without wrapping.
func NewNgramModelSetIterRef(ref unsafe.Pointer) *NgramModelSetIter {
	return (*NgramModelSetIter)(ref)
}

// NewNgramModelSetIter allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewNgramModelSetIter() *NgramModelSetIter {
	return (*NgramModelSetIter)(allocNgramModelSetIterMemory(1))
}

// allocNgramModelSetIterMemory allocates memory for type C.ngram_model_set_iter_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocNgramModelSetIterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfNgramModelSetIterValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfNgramModelSetIterValue = unsafe.Sizeof([1]C.ngram_model_set_iter_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *NgramModelSetIter) PassRef() *C.ngram_model_set_iter_t {
	if x == nil {
		x = (*NgramModelSetIter)(allocNgramModelSetIterMemory(1))
	}
	return (*C.ngram_model_set_iter_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Mllr) Ref() *C.ps_mllr_t {
	if x == nil {
		return nil
	}
	return (*C.ps_mllr_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Mllr) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMllrRef converts the C object reference into a raw struct reference without wrapping.
func NewMllrRef(ref unsafe.Pointer) *Mllr {
	return (*Mllr)(ref)
}

// NewMllr allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMllr() *Mllr {
	return (*Mllr)(allocMllrMemory(1))
}

// allocMllrMemory allocates memory for type C.ps_mllr_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMllrMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMllrValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMllrValue = unsafe.Sizeof([1]C.ps_mllr_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Mllr) PassRef() *C.ps_mllr_t {
	if x == nil {
		x = (*Mllr)(allocMllrMemory(1))
	}
	return (*C.ps_mllr_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *SearchIter) Ref() *C.ps_search_iter_t {
	if x == nil {
		return nil
	}
	return (*C.ps_search_iter_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *SearchIter) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewSearchIterRef converts the C object reference into a raw struct reference without wrapping.
func NewSearchIterRef(ref unsafe.Pointer) *SearchIter {
	return (*SearchIter)(ref)
}

// NewSearchIter allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewSearchIter() *SearchIter {
	return (*SearchIter)(allocSearchIterMemory(1))
}

// allocSearchIterMemory allocates memory for type C.ps_search_iter_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSearchIterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSearchIterValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSearchIterValue = unsafe.Sizeof([1]C.ps_search_iter_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *SearchIter) PassRef() *C.ps_search_iter_t {
	if x == nil {
		x = (*SearchIter)(allocSearchIterMemory(1))
	}
	return (*C.ps_search_iter_t)(unsafe.Pointer(x))
}

// allocFsgLinkMemory allocates memory for type C.fsg_link_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFsgLinkMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFsgLinkValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFsgLinkValue = unsafe.Sizeof([1]C.fsg_link_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FsgLink) Ref() *C.fsg_link_t {
	if x == nil {
		return nil
	}
	return x.refe7ca59ff
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FsgLink) Free() {
	if x != nil && x.allocse7ca59ff != nil {
		x.allocse7ca59ff.(*cgoAllocMap).Free()
		x.refe7ca59ff = nil
	}
}

// NewFsgLinkRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFsgLinkRef(ref unsafe.Pointer) *FsgLink {
	if ref == nil {
		return nil
	}
	obj := new(FsgLink)
	obj.refe7ca59ff = (*C.fsg_link_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FsgLink) PassRef() (*C.fsg_link_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe7ca59ff != nil {
		return x.refe7ca59ff, nil
	}
	meme7ca59ff := allocFsgLinkMemory(1)
	refe7ca59ff := (*C.fsg_link_t)(meme7ca59ff)
	allocse7ca59ff := new(cgoAllocMap)
	var cfrom_state_allocs *cgoAllocMap
	refe7ca59ff.from_state, cfrom_state_allocs = (C.int32)(x.FromState), cgoAllocsUnknown
	allocse7ca59ff.Borrow(cfrom_state_allocs)

	var cto_state_allocs *cgoAllocMap
	refe7ca59ff.to_state, cto_state_allocs = (C.int32)(x.ToState), cgoAllocsUnknown
	allocse7ca59ff.Borrow(cto_state_allocs)

	var clogs2prob_allocs *cgoAllocMap
	refe7ca59ff.logs2prob, clogs2prob_allocs = (C.int32)(x.Logs2prob), cgoAllocsUnknown
	allocse7ca59ff.Borrow(clogs2prob_allocs)

	var cwid_allocs *cgoAllocMap
	refe7ca59ff.wid, cwid_allocs = (C.int32)(x.Wid), cgoAllocsUnknown
	allocse7ca59ff.Borrow(cwid_allocs)

	x.refe7ca59ff = refe7ca59ff
	x.allocse7ca59ff = allocse7ca59ff
	return refe7ca59ff, allocse7ca59ff

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FsgLink) PassValue() (C.fsg_link_t, *cgoAllocMap) {
	if x.refe7ca59ff != nil {
		return *x.refe7ca59ff, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FsgLink) Deref() {
	if x.refe7ca59ff == nil {
		return
	}
	x.FromState = (int32)(x.refe7ca59ff.from_state)
	x.ToState = (int32)(x.refe7ca59ff.to_state)
	x.Logs2prob = (int32)(x.refe7ca59ff.logs2prob)
	x.Wid = (int32)(x.refe7ca59ff.wid)
}

// allocFsgModelMemory allocates memory for type C.fsg_model_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFsgModelMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFsgModelValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFsgModelValue = unsafe.Sizeof([1]C.fsg_model_t{})

type sliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSSByte transforms a sliced Go data structure into plain C format.
func unpackSSByte(x [][]byte) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.char)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(unsafe.Pointer(h.Data))
	return
}

// packSSByte reads sliced Go data structure out from plain C format.
func packSSByte(v [][]byte, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf95e7c8.Data = uintptr(unsafe.Pointer(ptr1))
		hxf95e7c8.Cap = 0x7fffffff
		// hxf95e7c8.Len = ?
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FsgModel) Ref() *C.fsg_model_t {
	if x == nil {
		return nil
	}
	return x.ref22935ee7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FsgModel) Free() {
	if x != nil && x.allocs22935ee7 != nil {
		x.allocs22935ee7.(*cgoAllocMap).Free()
		x.ref22935ee7 = nil
	}
}

// NewFsgModelRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFsgModelRef(ref unsafe.Pointer) *FsgModel {
	if ref == nil {
		return nil
	}
	obj := new(FsgModel)
	obj.ref22935ee7 = (*C.fsg_model_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FsgModel) PassRef() (*C.fsg_model_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref22935ee7 != nil {
		return x.ref22935ee7, nil
	}
	mem22935ee7 := allocFsgModelMemory(1)
	ref22935ee7 := (*C.fsg_model_t)(mem22935ee7)
	allocs22935ee7 := new(cgoAllocMap)
	var crefcount_allocs *cgoAllocMap
	ref22935ee7.refcount, crefcount_allocs = (C.int)(x.Refcount), cgoAllocsUnknown
	allocs22935ee7.Borrow(crefcount_allocs)

	var cname_allocs *cgoAllocMap
	ref22935ee7.name, cname_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Name)).Data)), cgoAllocsUnknown
	allocs22935ee7.Borrow(cname_allocs)

	var cn_word_allocs *cgoAllocMap
	ref22935ee7.n_word, cn_word_allocs = (C.int32)(x.NWord), cgoAllocsUnknown
	allocs22935ee7.Borrow(cn_word_allocs)

	var cn_word_alloc_allocs *cgoAllocMap
	ref22935ee7.n_word_alloc, cn_word_alloc_allocs = (C.int32)(x.NWordAlloc), cgoAllocsUnknown
	allocs22935ee7.Borrow(cn_word_alloc_allocs)

	var cvocab_allocs *cgoAllocMap
	ref22935ee7.vocab, cvocab_allocs = unpackSSByte(x.Vocab)
	allocs22935ee7.Borrow(cvocab_allocs)

	var csilwords_allocs *cgoAllocMap
	ref22935ee7.silwords, csilwords_allocs = (*C.bitvec_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Silwords)).Data)), cgoAllocsUnknown
	allocs22935ee7.Borrow(csilwords_allocs)

	var caltwords_allocs *cgoAllocMap
	ref22935ee7.altwords, caltwords_allocs = (*C.bitvec_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Altwords)).Data)), cgoAllocsUnknown
	allocs22935ee7.Borrow(caltwords_allocs)

	var clmath_allocs *cgoAllocMap
	ref22935ee7.lmath, clmath_allocs = (*C.logmath_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Lmath)).Data)), cgoAllocsUnknown
	allocs22935ee7.Borrow(clmath_allocs)

	var cn_state_allocs *cgoAllocMap
	ref22935ee7.n_state, cn_state_allocs = (C.int32)(x.NState), cgoAllocsUnknown
	allocs22935ee7.Borrow(cn_state_allocs)

	var cstart_state_allocs *cgoAllocMap
	ref22935ee7.start_state, cstart_state_allocs = (C.int32)(x.StartState), cgoAllocsUnknown
	allocs22935ee7.Borrow(cstart_state_allocs)

	var cfinal_state_allocs *cgoAllocMap
	ref22935ee7.final_state, cfinal_state_allocs = (C.int32)(x.FinalState), cgoAllocsUnknown
	allocs22935ee7.Borrow(cfinal_state_allocs)

	var clw_allocs *cgoAllocMap
	ref22935ee7.lw, clw_allocs = (C.float32)(x.Lw), cgoAllocsUnknown
	allocs22935ee7.Borrow(clw_allocs)

	x.ref22935ee7 = ref22935ee7
	x.allocs22935ee7 = allocs22935ee7
	return ref22935ee7, allocs22935ee7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FsgModel) PassValue() (C.fsg_model_t, *cgoAllocMap) {
	if x.ref22935ee7 != nil {
		return *x.ref22935ee7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FsgModel) Deref() {
	if x.ref22935ee7 == nil {
		return
	}
	x.Refcount = (int32)(x.ref22935ee7.refcount)
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.Name))
	hxfc4425b.Data = uintptr(unsafe.Pointer(x.ref22935ee7.name))
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

	x.NWord = (int32)(x.ref22935ee7.n_word)
	x.NWordAlloc = (int32)(x.ref22935ee7.n_word_alloc)
	packSSByte(x.Vocab, x.ref22935ee7.vocab)
	hxff2234b := (*sliceHeader)(unsafe.Pointer(&x.Silwords))
	hxff2234b.Data = uintptr(unsafe.Pointer(x.ref22935ee7.silwords))
	hxff2234b.Cap = 0x7fffffff
	// hxff2234b.Len = ?

	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.Altwords))
	hxff73280.Data = uintptr(unsafe.Pointer(x.ref22935ee7.altwords))
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ?

	hxfa9955c := (*sliceHeader)(unsafe.Pointer(&x.Lmath))
	hxfa9955c.Data = uintptr(unsafe.Pointer(x.ref22935ee7.lmath))
	hxfa9955c.Cap = 0x7fffffff
	// hxfa9955c.Len = ?

	x.NState = (int32)(x.ref22935ee7.n_state)
	x.StartState = (int32)(x.ref22935ee7.start_state)
	x.FinalState = (int32)(x.ref22935ee7.final_state)
	x.Lw = (float32)(x.ref22935ee7.lw)
}

// Ref returns a reference to C object as it is.
func (x *FsgArciter) Ref() *C.fsg_arciter_t {
	if x == nil {
		return nil
	}
	return (*C.fsg_arciter_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FsgArciter) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFsgArciterRef converts the C object reference into a raw struct reference without wrapping.
func NewFsgArciterRef(ref unsafe.Pointer) *FsgArciter {
	return (*FsgArciter)(ref)
}

// NewFsgArciter allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFsgArciter() *FsgArciter {
	return (*FsgArciter)(allocFsgArciterMemory(1))
}

// allocFsgArciterMemory allocates memory for type C.fsg_arciter_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFsgArciterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFsgArciterValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFsgArciterValue = unsafe.Sizeof([1]C.fsg_arciter_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FsgArciter) PassRef() *C.fsg_arciter_t {
	if x == nil {
		x = (*FsgArciter)(allocFsgArciterMemory(1))
	}
	return (*C.fsg_arciter_t)(unsafe.Pointer(x))
}

// packSArg reads sliced Go data structure out from plain C format.
func packSArg(v []Arg, ptr0 *C.arg_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfArgValue]C.arg_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewArgRef(unsafe.Pointer(&ptr1))
	}
}

// allocPMfccMemory allocates memory for type *C.mfcc_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPMfccMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPMfccValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPMfccValue = unsafe.Sizeof([1]*C.mfcc_t{})

// unpackArgSSFloat32 transforms a sliced Go data structure into plain C format.
func unpackArgSSFloat32(x [][]float32) (unpacked **C.mfcc_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.mfcc_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPMfccMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.mfcc_t)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.mfcc_t)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.mfcc_t)(unsafe.Pointer(h.Data))
	return
}

// packSSFloat32 reads sliced Go data structure out from plain C format.
func packSSFloat32(v [][]float32, ptr0 **C.mfcc_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.mfcc_t)(unsafe.Pointer(ptr0)))[i0]
		hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfa3f05c.Data = uintptr(unsafe.Pointer(ptr1))
		hxfa3f05c.Cap = 0x7fffffff
		// hxfa3f05c.Len = ?
	}
}

// allocPInt16Memory allocates memory for type *C.int16 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPInt16Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPInt16Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPInt16Value = unsafe.Sizeof([1]*C.int16{})

// unpackArgSSInt16 transforms a sliced Go data structure into plain C format.
func unpackArgSSInt16(x [][]int16) (unpacked **C.int16, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.int16) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPInt16Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.int16)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.int16)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.int16)(unsafe.Pointer(h.Data))
	return
}

// packSSInt16 reads sliced Go data structure out from plain C format.
func packSSInt16(v [][]int16, ptr0 **C.int16) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.int16)(unsafe.Pointer(ptr0)))[i0]
		hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf0d18b7.Data = uintptr(unsafe.Pointer(ptr1))
		hxf0d18b7.Cap = 0x7fffffff
		// hxf0d18b7.Len = ?
	}
}

// unpackArgSArg transforms a sliced Go data structure into plain C format.
func unpackArgSArg(x []Arg) (unpacked *C.arg_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.arg_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocArgMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.arg_t)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.arg_t)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSSByte transforms a sliced Go data structure into plain C format.
func unpackArgSSByte(x [][]byte) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.char)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(unsafe.Pointer(h.Data))
	return
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}

// unpackArgSString transforms a sliced Go data structure into plain C format.
func unpackArgSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(unsafe.Pointer(h.Data))
	return
}
